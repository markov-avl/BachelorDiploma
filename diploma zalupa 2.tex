\subsection{Дизайн тестовых сценариев}
\label{subsec:test-design}

Тест дизайн -- один из первоначальных этапов тестирования программного обеспечения, этап планирования и проектирования тестов. Тест дизайн представляет собой продумывание и написание тестовых случаев, в соответствии с требованиями проекта, критериями качества будущего продукта и финальными целями тестирования.

Цели тест дизайна:
Обеспечить покрытие функционала приложения тестами:
\begin{enumerate}
    \item Тесты должны покрывать весь функционал
    \item Тестов должно быть минимально достаточно
\end{enumerate}

Задачи тест дизайна:
\begin{enumerate}
    \item Проанализировать требования к продукту
    \item Оценить риски возможные при использовании продукта
    \item Написать достаточное минимальное количество тестов
    \item Разграничить тесты на приемочные, критические, расширенные
\end{enumerate}

Существуют несколько техник тест дизайна. Рассмотрим следующие:
\begin{enumerate}
    \item Тестирование классами эквивалентности (Equivalence Class Testing)
    \item Тестирование граничных значений (Boundary Value Testing)
    \item Таблица принятия решений (Decision Table Testing)
\end{enumerate}

\subsubsection{Тестирование классами эквивалентности}
\label{subsubsec:equivalence-classes}

Класс эквивалентности (equivalence class) -- одно или несколько значений ввода, к которым программное обеспечение применяет одинаковую логику.

Два теста можно считать эквивалентными, в случае когда:
\begin{enumerate}
    \item они проверяют одну и ту же часть системы (функцию, модуль);
    \item один тест находит ошибку, то и другой, скорее всего, найдет ошибку и наоборот (если один не находит ошибку – второй также не находит);
    \item они используют сходные наборы входных данных;
    \item чтобы выполнить тесты, необходимо совершить одни и те же операции;
    \item в результате проведения тестов получаем одинаковые выходные данные и система находится в одном и том же состоянии;
    \item срабатывает один и тот же блок обработки ошибки;
    \item не срабатывает блок обработки ошибки.
\end{enumerate}

Шаги применения техники разделения на классы эквивалентности, следующие:
\begin{enumerate}
    \item Определить классы эквивалентности;
    \item выбрать представителя каждого класса;
    \item выполнить тесты.
\end{enumerate}

Пример выполнения: есть поле ввода с диапазоном допустимых значений от 1 до 100. Если проверять каждое значение из этого диапазона, это будет очень долго и не эффективно. В данном примере можно выделить 2 класса эквивалентности:
\begin{enumerate}
    \item Допустимые значения(от 1 до 100)
    \item Недопустимые значения:
    \begin{enumerate}
        \item от -$\infty$ до 0
        \item от 101 до +$\infty$
        \item буквы
        \item специальные символы(@-#!)
    \end{enumerate}
\end{enumerate}
Используя классы эквивалентности можно протестировать поле ввода минимум из 5 тестов.

\subsubsection{Тестирование граничных значений}
\label{subsubsec:boundary-testing}

Граничные значения -- это те места, в которых один класс эквивалентности переходит в другой.

На каждой границе диапазона следует проверить по три значения:
\begin{enumerate}
    \item граничное значение;
    \item значение перед границей;
    \item значение после границы.
\end{enumerate}

Цель этой техники -- найти ошибки, связанные с граничными значениями.

Алгоритм использования техники граничных значений:
\begin{enumerate}
    \item выделить классы эквивалентности;
    \item определить граничные значения этих классов;
    \item нужно понять, к какому классу будет относиться каждая граница;
    \item нужно провести тесты по проверке значения до границы, на границе и сразу после границы.
\end{enumerate}

Пример использования: 
Условие -- в поля ввода можно внести только целые числа от 0 до 10 000.
Определяемся с существующими границами --  так как в условии все значения от 0 до 10 000 приведут к одному и тому же результату, то границы две: нижняя и верхняя.
Первое граничное значение -- 0
Второе граничное значение -- 10 000
Добавляем к ним, стоящие рядом значения:
\begin{enumerate}
    \item -1, 0, 1
    \item 9 999, 10 000, 10 001
\end{enumerate}

\subsubsection{Таблица принятия решений}
\label{subsubsec:Decision-Table}

Таблица решений -- способ компактного представления модели со сложной логикой; инструмент для упорядочения сложных бизнес требований, которые должны быть реализованы в продукте. Это взаимосвязь между множеством условий и действий.

Таблица принятия решений, как правило, разделяется на 4 квадранта:
\begin{enumerate}
    \item Условия -- список возможных условий.
    \item Варианты выполнения действий -- комбинация из выполнения и/или невыполнения условий этого списка.
    \item Действия -- список возможных действий.
    \item Необходимость действий -- указание надо или не надо выполнять соответствующее действие для каждой из комбинаций условий.
\end{enumerate}

Рассмотрим таблицу принятия решений на примере страницы регистрации нового пользователя.
Используем понятия “корректные” и “некорректные” данные.
Чтобы регистрация прошла успешно, необходимо заполнить корректными оба поля. Если поля заполняются некорректными данными, то система должна выдать ошибку: “Введены невалидные данные”.
%cюда хуйню вставить(таблицу)
Значения 2, 3, 4 приводят к одному и тому же результату с разными входными значениями.

\subsection{Обзор существующих решений}
\label{subsec:existingsolutions}

Системы автоматического тестирования делятся на два типа:
\begin{enumerate}
    \item Системы автоматическо создания тестов;
    \item Cистемы автоматического запуска тестов;
\end{enumerate}

Примеры систем автоматического создания тестов:
\begin{enumerate}
    \item IntelliTest
\end{enumerate}

Примеры систем автоматического запуска тестов:
\begin{enumerate}
    \item PYtest
    \item Unittest
    \item Googletest
\end{enumerate}

\textbf{IntelliTest}
IntelliTest позволяет находить ошибки на раннем этапе и уменьшает затраты на обслуживание тестирования. Благодаря автоматизированному и прозрачному подходу к тестированию инструмент IntelliTest позволяет сформировать набор кандидатов на тесты для кода .NET. Создание набора тестов можно дополнительно настроить с помощью задаваемых вами свойств правильности. IntelliTest даже будет автоматически модифицировать набор тестов по мере модификации тестируемого кода.
Характеристические тесты. IntelliTest позволяет определить поведение кода в рамках набора традиционных модульных тестов. Подобный набор тестов можно использовать в качестве набора регрессии, чтобы сформировать основу для преодоления сложностей, связанных с рефакторингом незнакомого кода или кода прежних версий.
Управляемое создание входных данных для теста. Инструмент IntelliTest использует открытый подход к анализу кода и поиску решений для ограничений, чтобы автоматически создавать точные входные значения для тестов, при этом вмешательство пользователя обычно не требуется. Для сложных типов объектов он автоматически создает фабрики. Вы можете управлять созданием входных данных для теста, расширяя и настраивая фабрики в соответствии с вашими требованиями. Свойства правильности, заданные в коде в качестве утверждений, также будут автоматически использоваться для дальнейшего управления созданием входных данных.
Интеграция со средой IDE. Инструмент IntelliTest полностью интегрирован в среду IDE Visual Studio. Все данные, собранные во время создания набора тестов (например, автоматически созданные входные данные, выходные данные кода, созданные тестовые случаи и состояние их выполнения), отображаются в интегрированной среде разработки Visual Studio. Вы можете легко переключаться между правкой кода и повторным выполнением IntelliTest, не выходя из среды IDE Visual Studio. Тесты можно сохранить в качестве решения — проекта модульных тестов, после чего их автоматически определит обозреватель тестов Visual Studio.

\textbf{PYtest}
Pytest - это фреймворк, упрощающий создание простых и масштабируемых тестов. Тесты выразительны и удобочитаемы - шаблонный код не требуется.

\textbf{Unittest}
В Python встроен модуль unittest, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.
Для автоматизации тестов unittest поддерживает некоторые важные концепции:
Испытательный стенд (test fixture) - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.
Тестовый случай (test case) - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс TestCase, который можно использовать для создания новых тестовых случаев.
Набор тестов (test suite) - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.
Исполнитель тестов (test runner) - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.
Модуль unittest предоставляет богатый набор инструментов для написания и запуска тестов. Однако достаточно лишь некоторых из них, чтобы удовлетворить потребности большинства пользователей.
%Cпиздил у михеева PYtest и Unittest описание ПОХУЙУЙУЙУЙУЙУЙУй

\textbf{GoogleTest}
Google C++ Testing Framework (Google Test) — библиотека для модульного тестирования на языке С++.
Google Test построена на методологии тестирования xUnit, то есть когда отдельные части программы (классы, функции, модули) проверяются отдельно друг от друга, в изоляции. Библиотека сама по себе разработана с активным применением тестирования, когда при добавлении каких-либо частей в официальную версию, кроме кода самих изменений необходимо написать набор тестов, подтверждающих их корректность.









