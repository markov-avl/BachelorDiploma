\subsection{Классификации видов и методов тестирования}\label{subsec:classifications}

Существует несколько признаков, по которым принято производить классификацию видов тестирования. Обычно выделяют следующие:
\begin{enumerate}
    \item По объекту тестирования:
        \begin{itemize}
            \item функциональное тестирование;
            \item тестирование производительности;
            \item нагрузочное тестирование;
            \item стресс-тестирование;
            \item тестирование стабильности;
            \item конфигурационное тестирование;
            \item юзабилити-тестирование;
            \item тестирование безопасности;
            \item тестирование локализации;
            \item тестирование совместимости.
        \end{itemize}
    \item По знанию внутреннего строения системы:
        \begin{itemize}
            \item тестирование чёрного ящика;
            \item тестирование белого ящика;
            \item тестирование серого ящика.
        \end{itemize}
    \item По степени автоматизации:
        \begin{itemize}
            \item ручное тестирование;
            \item автоматизированное тестирование;
            \item полуавтоматизированное тестирование.
        \end{itemize}
    \item По степени изолированности:
        \begin{itemize}
            \item тестирование компонентов;
            \item интеграционное тестирование;
            \item системное тестирование.
        \end{itemize}
    \item По времени проведения тестирования:
        \begin{itemize}
            \item альфа-тестирование;
            \item бета-тестирование.
        \end{itemize}
    \item По признаку позитивности сценариев:
        \begin{itemize}
            \item позитивное тестирование;
            \item негативное тестирование.
        \end{itemize}
    \item По степени подготовленности к тестированию:
        \begin{itemize}
            \item тестирование по документации (формальное тестирование);
            \item интуитивное тестирование.
        \end{itemize}
\end{enumerate}

% всё, что выше, украдено с википедии: https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения

% TODO: ПОТОМ ИСПРАВИТЬ "КУРСОВОЙ"
В рамках данной курсовой работы мы рассмотрим наиболее подробно следующие классификации: по по запуску кода на исполнение,


1.4.1 Классификация по запуску кода на исполнение
Далеко не всякое тестирование предполагает взаимодействие с работающим приложением.
Потому в рамках данной классификации выделяют:
    1. Статическое тестирование (static testing) — тестирование без запуска кода на исполнение. В рамках этого подхода тестированию могут подвергаться:
    • Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.).
    • Графические прототипы (например, эскизы пользовательского интерфейса).
    • Код приложения. Код приложения также можно проверять с использованием техник тестирования на основе структур кода.
    • Параметры (настройки) среды исполнения приложения.
    • Подготовленные тестовые данные.
    2. Динамическое тестирование — тестирование с запуском кода на исполнение. Запускаться на исполнение может как код всего приложения целиком (системное тестирование), так и код нескольких взаимосвязанных частей (интеграционное тестирование), отдельных частей (модульное или компонентное тестирование) и даже отдельные участки кода. Основная идея этого вида тестирования состоит в том, что проверяется реальное поведение (части) приложения.
1.4.2 Классификация по доступу к коду приложения
Черный ящик - тестирование методом «черного ящика», также известное как тестирование, основанное на спецификации или тестирование поведения – техника тестирования, основанная на работе исключительно с внешними интерфейсами тестируемой системы. Согласно ISTQB:
тестирование черного ящика – это:
    •  тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента или системы.
    •  тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства.
Целью этой метода является поиск ошибок в таких категориях:
    •  неправильно реализованные или недостающие функции;
    •  ошибки интерфейса;
    •  ошибки в структурах данных или организации доступа к внешним базам данных;
    •  ошибки поведения или недостаточная производительности системы;
Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. Нужно концентрироваться на том, что программа делает, а не на том, как она это делает.
Методы тестирования с помощью черного ящика: 
    1.1. Эквивалентное разбиение.
    1.2. Анализ граничных значений.
    1.1. Эквивалентное разбиение. Основу метода составляют два положения:
1. Исходные данные необходимо разбить на конечное число классов эквивалентности. В одном классе эквивалентности содержатся такие тесты, что если один тест из класса эквивалентности обнаруживает некоторую ошибку, то и любой другой тест из этого класса эквивалентности должен обнаруживать эту же ошибку.
2. Каждый тест должен включать, по возможности, максимальное количество классов эквивалентности, чтобы минимизировать общее число тестов.
Разработка тестов этим методом осуществляется в два этапа: выделение классов эквивалентности и построение теста.
    1.2. Анализ граничных значений 
Граничные условия— это ситуации, возникающие на высших и нижних границах входных классов эквивалентности.
Анализ граничных значений отличается от эквивалентного разбиения следующим:
    1. Выбор любого элемента в классе эквивалентности в качестве представительного осуществляется таким образом, чтобы проверить тестом каждую границу этого класса.
    2. При разработке тестов рассматриваются не только входные значения (пространство входов), но и выходные (пространство выходов).
Анализ граничных значений, если он применён правильно, позволяет обнаружить большое число ошибок. Однако определение этих границ для каждой задачи может являться отдельной трудной задачей. Также этот метод не проверяет комбинации входных значений.
    1. Белый ящик - тестирование методом белого ящика (также: прозрачного, открытого, стеклянного ящика; основанное на коде или структурное тестирование) – метод тестирования программного обеспечения, который предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику. Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Точно так же мы знаем, каким должен быть результат этой обработки. Знание всех особенностей тестируемой программы и ее реализации – обязательны для этой техники. Тестирование белого ящика – углубление во внутренне устройство системы, за пределы ее внешних интерфейсов.
Согласно ISTQB, тестирование белого ящика – это:
    •  тестирование, основанное на анализе внутренней структуры компонента или системы.
    •  тест-дизайн, основанный на технике белого ящика – процедура написания или выбора тест-кейсов на основе анализа внутреннего устройства системы или компонента.
В процессе моделирования тестовых сценариев стараются покрыть код. Покрытие кода — мера, используемая при тестировании программного обеспечения. Она показывает процент исходного кода программы, который был выполнен в процессе тестирования. Существует несколько различных способов измерения покрытия, основные из них:
    1. покрытие операторов — каждая ли строка исходного кода была выполнена и протестирована;
    2. покрытие условий — каждая ли точка решения (вычисления истинно ли или ложно выражение) была выполнена и протестирована;
    3. покрытие путей — все ли возможные пути через заданную часть кода были выполнены и протестированы;
    4. покрытие функций — каждая ли функция программы была выполнена;
    5. покрытие вход/выход — все ли вызовы функций и возвраты из них были выполнены.
    6. покрытие значений параметров — все ли типовые и граничные значения параметров были проверены.
Таблица преимуществ и недостатков методов белого и черного ящика представлена в таблице 2.
Таблица 2 - преимущества и недостатки методов белого и черного ящика

Преимущества
Недостатки
Метод белого ящика
    • Показывает скрытые проблемы и упрощает их диагностику.


    • Не может выполняться тестировщиками, не обладающими достаточными знаниями в области программирования.

Окончание таблицы 2
Метод белого ящика
    • Допускает достаточно простую автоматизацию тест-кейсов и их выполнение на самых ранних стадиях развития проекта.
    • Обладает развитой системой метрик, сбор и анализ которых легко автоматизируется.
    • Стимулирует разработчиков к написанию качественного кода.
    • Многие техники этого метода являются проверенными, хорошо себя зарекомендовавшими решениями, базирующимися на строгом техническом подходе
    • Тестирование сфокусировано на реализованной функциональности, что повышает вероятность пропуска нереализованных требований.
    • Поведение приложения исследуется в отрыве от реальной среды выполнения и не учитывает её влияние.
    • Поведение приложения исследуется в отрыве от реальных пользовательских сценариев.
Метод черного ящика
    • Тестировщик не обязан обладать (глубокими) знаниями в области программирования.
    • Поведение приложения исследуется в контексте реальной среды выполнения и учитывает её влияние.
    • Поведение приложения исследуется в контексте реальных пользовательских сценариев.
    • Тест-кейсы можно создавать уже на стадии появления стабильных требований.
    • Процесс создания тест-кейсов позволяет выявить дефекты в требованиях.
    • Допускает создание тест-кейсов, которые можно многократно использовать на разных проектах.
Возможно повторение части тест-кейсов, уже выполненных разработчиками.
• Высока вероятность того, что часть возможных вариантов поведения приложения останется непротестированной.
• Для разработки высокоэффективных тест-кейсов необходима качественная документация.
• Диагностика обнаруженных дефектов более сложна в сравнении с техниками метода белого ящика.
• В связи с широким выбором техник и подходов затрудняется планирование и оценка трудозатрат.
• В случае автоматизации могут потребоваться сложные дорогостоящие инструментальные средства.
            1.4.3 Классификация по степени автоматизации
Ручное тестирование (manual testing) — тестирование, в котором тест-кейсы выполняются человеком вручную без использования средств автоматизации.
Автоматизированное тестирование (automated testing, test automation) — набор техник, подходов и инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования. Тест-кейсы частично или полностью выполняет специальное инструментальное средство, однако разработка тест-кейсов, подготовка данных, оценка результатов выполнения, написания отчётов об обнаруженных дефектах — всё это и многое другое по-прежнему делает вручную.
Таблица преимуществ и недостатков автоматизированного тестирования представлена на таблице 2
Таблица 2
Преимущества
Недостатки
    • Скорость выполнения тест-кейсов может в разы и на порядки превосходить возможности человека.
    • Отсутствие влияния человеческого фактора в процессе выполнения тест-кейсов
    • Минимизация затрат при многократном выполнении тест-кейсов (участие человека здесь требуется лишь эпизодически).
    • Способность средств автоматизации выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов.
    • Способность средств автоматизации собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объёмы данных.
    • Способность средств автоматизации выполнять низкоуровневые действия с приложением, операционной системой, каналами передачи данных и т. д.
    • Высокие затраты на сложные средства автоматизации, разработку и сопровождение кода тест-кейсов.
    • Автоматизация требует более тщательного планирования и управления рисками, т. к. в противном случае проекту может быть нанесён серьёзный ущерб.
    • В случае ощутимого изменения требований,
    • смены технологического домена, переработки интерфейсов (как пользовательских, так и программных) многие тест-кейсы становятся безнадёжно устаревшими и требуют создания заново.
            1.4.4  Классификация по уровню тестирования
Широко используемыми уровнями тестирования являются модульное тестирование, интеграционное тестирование и комплексное тестирование. [2]
    1. Модульное
Тестирование модуля (unit testing) — заключается в изолированной проверке каждого отдельного элемента путем запуска тестов в искусственной среде. Для этого необходимо использовать драйверы и заглушки. Поэлементное тестирование — первейшая возможность реализовать исходный код. Оценивая каждый элемент изолированно и подтверждая корректность его работы, точно установить проблему значительно проще чем, если бы элемент был частью системы.
Модуль (unit) — наименьший компонент, который можно скомпилировать.
Заглушки — заменяют недостающие компоненты, которые вызываются элементом и выполняют следующие действия:
    • возвращаются к элементу, не выполняя никаких других действий;
    • отображают трассировочное сообщение и иногда предлагают тестеру продолжить тестирование;
    • возвращают постоянное значение или предлагают тестеру самому ввести возвращаемое значение;
    • осуществляют упрощенную реализацию недостающей компоненты;
    • Имитируют исключительные или аварийные условия.
    2. Интеграционное тестирование 
Интеграционное тестирование предназначено для проверки связи между компонентами, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). Уровни интеграционного тестирования:
    • Компонентный интеграционный уровень (Component Integration testing) - Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.
    • Системный интеграционный уровень (System Integration Testing) - проверяется взаимодействие между разными системами после проведения системного тестирования.
Подходы к интеграционному тестированию:
    2.1. Снизу вверх (Bottom Up Integration).
Все низкоуровневые модули, процедуры или функции собираются воедино и затем тестируются. После чего собирается следующий уровень модулей для проведения интеграционного тестирования. Данный подход считается полезным, если все или практически все модули, разрабатываемого уровня, готовы. Также данный подход помогает определить по результатам тестирования уровень готовности приложения 
    2.2. Сверху вниз (Top Down Integration).
Вначале тестируются все высокоуровневые модули, и постепенно один за другим добавляются низкоуровневые. Все модули более низкого уровня симулируются заглушками с аналогичной функциональностью, затем по мере готовности они заменяются реальными активными компонентами. Таким образом мы проводим тестирование сверху вниз
    2.3. Большой взрыв ("Big Bang" Integration)
Все или практически все разработанные модули собираются вместе в виде законченной системы или ее основной части, и затем проводится интеграционное тестирование. Такой подход очень хорош для сохранения времени. Однако если тест кейсы и их результаты записаны не верно, то сам процесс интеграции сильно осложнится.
    3. Системное тестирование
Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т. д. Для минимизации рисков, связанных с особенностями поведения в системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи.
Можно выделить два подхода к системному тестированию:
    • на базе требований (requirements based).
Для каждого требования пишутся тестовые сценарии (test suits), проверяющие выполнение данного требования.
    • на базе случаев использования (use case based).
На основе представления о способах использования продукта создаются случаи использования системы (use Cases). По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся тестовые сценарии (test suits), которые должны быть протестированы. Схема представления по уровню представлена на рисунке 2.

Рисунок 2. Схема представления классификации тестирования по уровню
Дымовое тестирование (smoke test, intake test, build verification test) Выборка из общего числа запланированных тестовых сценариев, покрывающая основную функциональность компонента или системы. Проводится с целью удостовериться, что базовые функции программы в целом работают корректно, без углубления в детали. Ежедневная сборка и тест "на дым" являются передовыми практическими методами. Дымовое тестирование проводится после каждой пригодной для работы версии, чтобы определить общий уровень качества приложения и принять решение о (не)целесообразности выполнения тестирования критического пути и расширенного тестирования. Поскольку тест-кейсов на уровне дымового тестирования относительно немного, а сами они достаточно просты, но при этом очень часто повторяются, они являются хорошими кандидатами на автоматизацию. В связи с высокой важностью тест-кейсов на данном уровне пороговое значение метрики их прохождения часто выставляется равным 100 % или близким к 100 %.
Тестирование критического пути (critical path test) направлено на исследование функциональности, используемой типичными пользователями в типичной повседневной деятельности. Как видно из определения в сноске к англоязычной версии термина, сама идея позаимствована из управления проектами и трансформирована в контексте тестирования в следующую: существует большинство пользователей, которые чаще всего используют некое подмножество функций приложения (см. рисунок 3). Именно эти функции и нужно проверить, как только мы убедились, что приложение работает (дымовой тест прошёл успешно). Пороговое значение метрики успешного прохождения «теста критического пути» ниже чем при дымовом тестировании (как правило, порядка 70–90 %).

Рисунок 3.Суть тестирования Критического пути
Расширенное тестирование (extended test) направлено на исследование всей заявленной в требованиях функциональности. Но при наличии достаточного количества времени и иных ресурсов тест-кейсы этого уровня могут затронуть даже самые низкоприоритетные требования. Ещё одним направлением исследования в рамках данного тестирования являются нетипичные, маловероятные, экзотические случаи и сценарии использования функций и свойств приложения, затронутых на предыдущих уровнях. Пороговое значение метрики успешного прохождения расширенного тестирования существенно ниже, чем в тестировании критического пути (значения в диапазоне 30–50\%).